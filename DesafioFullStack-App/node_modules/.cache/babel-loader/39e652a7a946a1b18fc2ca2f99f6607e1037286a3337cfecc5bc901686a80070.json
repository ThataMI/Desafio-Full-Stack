{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\nfunction createCommonjsModule(fn) {\n  var module = {\n    exports: {}\n  };\n  return fn(module, module.exports), module.exports;\n}\nvar stringMask = createCommonjsModule(function (module, exports) {\n  (function (root, factory) {\n    /* istanbul ignore next */\n    {\n      // Node. Does not work with strict CommonJS, but\n      // only CommonJS-like environments that support module.exports,\n      // like Node.\n      module.exports = factory();\n    }\n  })(commonjsGlobal, function () {\n    var tokens = {\n      '0': {\n        pattern: /\\d/,\n        _default: '0'\n      },\n      '9': {\n        pattern: /\\d/,\n        optional: true\n      },\n      '#': {\n        pattern: /\\d/,\n        optional: true,\n        recursive: true\n      },\n      'A': {\n        pattern: /[a-zA-Z0-9]/\n      },\n      'S': {\n        pattern: /[a-zA-Z]/\n      },\n      'U': {\n        pattern: /[a-zA-Z]/,\n        transform: function (c) {\n          return c.toLocaleUpperCase();\n        }\n      },\n      'L': {\n        pattern: /[a-zA-Z]/,\n        transform: function (c) {\n          return c.toLocaleLowerCase();\n        }\n      },\n      '$': {\n        escape: true\n      }\n    };\n    function isEscaped(pattern, pos) {\n      var count = 0;\n      var i = pos - 1;\n      var token = {\n        escape: true\n      };\n      while (i >= 0 && token && token.escape) {\n        token = tokens[pattern.charAt(i)];\n        count += token && token.escape ? 1 : 0;\n        i--;\n      }\n      return count > 0 && count % 2 === 1;\n    }\n    function calcOptionalNumbersToUse(pattern, value) {\n      var numbersInP = pattern.replace(/[^0]/g, '').length;\n      var numbersInV = value.replace(/[^\\d]/g, '').length;\n      return numbersInV - numbersInP;\n    }\n    function concatChar(text, character, options, token) {\n      if (token && typeof token.transform === 'function') {\n        character = token.transform(character);\n      }\n      if (options.reverse) {\n        return character + text;\n      }\n      return text + character;\n    }\n    function hasMoreTokens(pattern, pos, inc) {\n      var pc = pattern.charAt(pos);\n      var token = tokens[pc];\n      if (pc === '') {\n        return false;\n      }\n      return token && !token.escape ? true : hasMoreTokens(pattern, pos + inc, inc);\n    }\n    function hasMoreRecursiveTokens(pattern, pos, inc) {\n      var pc = pattern.charAt(pos);\n      var token = tokens[pc];\n      if (pc === '') {\n        return false;\n      }\n      return token && token.recursive ? true : hasMoreRecursiveTokens(pattern, pos + inc, inc);\n    }\n    function insertChar(text, char, position) {\n      var t = text.split('');\n      t.splice(position, 0, char);\n      return t.join('');\n    }\n    function StringMask(pattern, opt) {\n      this.options = opt || {};\n      this.options = {\n        reverse: this.options.reverse || false,\n        usedefaults: this.options.usedefaults || this.options.reverse\n      };\n      this.pattern = pattern;\n    }\n    StringMask.prototype.process = function proccess(value) {\n      if (!value) {\n        return {\n          result: '',\n          valid: false\n        };\n      }\n      value = value + '';\n      var pattern2 = this.pattern;\n      var valid = true;\n      var formatted = '';\n      var valuePos = this.options.reverse ? value.length - 1 : 0;\n      var patternPos = 0;\n      var optionalNumbersToUse = calcOptionalNumbersToUse(pattern2, value);\n      var escapeNext = false;\n      var recursive = [];\n      var inRecursiveMode = false;\n      var steps = {\n        start: this.options.reverse ? pattern2.length - 1 : 0,\n        end: this.options.reverse ? -1 : pattern2.length,\n        inc: this.options.reverse ? -1 : 1\n      };\n      function continueCondition(options) {\n        if (!inRecursiveMode && !recursive.length && hasMoreTokens(pattern2, patternPos, steps.inc)) {\n          // continue in the normal iteration\n          return true;\n        } else if (!inRecursiveMode && recursive.length && hasMoreRecursiveTokens(pattern2, patternPos, steps.inc)) {\n          // continue looking for the recursive tokens\n          // Note: all chars in the patterns after the recursive portion will be handled as static string\n          return true;\n        } else if (!inRecursiveMode) {\n          // start to handle the recursive portion of the pattern\n          inRecursiveMode = recursive.length > 0;\n        }\n        if (inRecursiveMode) {\n          var pc = recursive.shift();\n          recursive.push(pc);\n          if (options.reverse && valuePos >= 0) {\n            patternPos++;\n            pattern2 = insertChar(pattern2, pc, patternPos);\n            return true;\n          } else if (!options.reverse && valuePos < value.length) {\n            pattern2 = insertChar(pattern2, pc, patternPos);\n            return true;\n          }\n        }\n        return patternPos < pattern2.length && patternPos >= 0;\n      }\n\n      /**\n       * Iterate over the pattern's chars parsing/matching the input value chars\n       * until the end of the pattern. If the pattern ends with recursive chars\n       * the iteration will continue until the end of the input value.\n       *\n       * Note: The iteration must stop if an invalid char is found.\n       */\n      for (patternPos = steps.start; continueCondition(this.options); patternPos = patternPos + steps.inc) {\n        // Value char\n        var vc = value.charAt(valuePos);\n        // Pattern char to match with the value char\n        var pc = pattern2.charAt(patternPos);\n        var token = tokens[pc];\n        if (recursive.length && token && !token.recursive) {\n          // In the recursive portion of the pattern: tokens not recursive must be seen as static chars\n          token = null;\n        }\n\n        // 1. Handle escape tokens in pattern\n        // go to next iteration: if the pattern char is a escape char or was escaped\n        if (!inRecursiveMode || vc) {\n          if (this.options.reverse && isEscaped(pattern2, patternPos)) {\n            // pattern char is escaped, just add it and move on\n            formatted = concatChar(formatted, pc, this.options, token);\n            // skip escape token\n            patternPos = patternPos + steps.inc;\n            continue;\n          } else if (!this.options.reverse && escapeNext) {\n            // pattern char is escaped, just add it and move on\n            formatted = concatChar(formatted, pc, this.options, token);\n            escapeNext = false;\n            continue;\n          } else if (!this.options.reverse && token && token.escape) {\n            // mark to escape the next pattern char\n            escapeNext = true;\n            continue;\n          }\n        }\n\n        // 2. Handle recursive tokens in pattern\n        // go to next iteration: if the value str is finished or\n        //                       if there is a normal token in the recursive portion of the pattern\n        if (!inRecursiveMode && token && token.recursive) {\n          // save it to repeat in the end of the pattern and handle the value char now\n          recursive.push(pc);\n        } else if (inRecursiveMode && !vc) {\n          // in recursive mode but value is finished. Add the pattern char if it is not a recursive token\n          formatted = concatChar(formatted, pc, this.options, token);\n          continue;\n        } else if (!inRecursiveMode && recursive.length > 0 && !vc) {\n          // recursiveMode not started but already in the recursive portion of the pattern\n          continue;\n        }\n\n        // 3. Handle the value\n        // break iterations: if value is invalid for the given pattern\n        if (!token) {\n          // add char of the pattern\n          formatted = concatChar(formatted, pc, this.options, token);\n          if (!inRecursiveMode && recursive.length) {\n            // save it to repeat in the end of the pattern\n            recursive.push(pc);\n          }\n        } else if (token.optional) {\n          // if token is optional, only add the value char if it matchs the token pattern\n          //                       if not, move on to the next pattern char\n          if (token.pattern.test(vc) && optionalNumbersToUse) {\n            formatted = concatChar(formatted, vc, this.options, token);\n            valuePos = valuePos + steps.inc;\n            optionalNumbersToUse--;\n          } else if (recursive.length > 0 && vc) {\n            valid = false;\n            break;\n          }\n        } else if (token.pattern.test(vc)) {\n          // if token isn't optional the value char must match the token pattern\n          formatted = concatChar(formatted, vc, this.options, token);\n          valuePos = valuePos + steps.inc;\n        } else if (!vc && token._default && this.options.usedefaults) {\n          // if the token isn't optional and has a default value, use it if the value is finished\n          formatted = concatChar(formatted, token._default, this.options, token);\n        } else {\n          // the string value don't match the given pattern\n          valid = false;\n          break;\n        }\n      }\n      return {\n        result: formatted,\n        valid: valid\n      };\n    };\n    StringMask.prototype.apply = function (value) {\n      return this.process(value).result;\n    };\n    StringMask.prototype.validate = function (value) {\n      return this.process(value).valid;\n    };\n    StringMask.process = function (value, pattern, options) {\n      return new StringMask(pattern, options).process(value);\n    };\n    StringMask.apply = function (value, pattern, options) {\n      return new StringMask(pattern, options).apply(value);\n    };\n    StringMask.validate = function (value, pattern, options) {\n      return new StringMask(pattern, options).validate(value);\n    };\n    return StringMask;\n  });\n});\nconst getInputElement = el => {\n  const inputEl = el.tagName.toLowerCase() !== 'input' ? el.querySelector('input:not([readonly])') : el;\n  if (!inputEl) {\n    throw new Error('Mask directive requires at least one input');\n  }\n  return inputEl;\n};\nfunction createEvent(name) {\n  const event = document.createEvent('HTMLEvents');\n  event.initEvent(name, true, true);\n  return event;\n}\nconst filterNumbers = v => v.replace(/\\D/g, '');\nconst filterLetters = v => v.replace(/[^a-zA-Z]/g, '');\nconst filterAlphanumeric = v => v.replace(/[^a-zA-Z0-9]/g, '');\nconst parsePreFn = arg => {\n  if (typeof arg === 'function') {\n    return arg;\n  }\n  switch (arg) {\n    case 'filter-number':\n      return filterNumbers;\n    case 'filter-letter':\n      return filterLetters;\n    default:\n      return filterAlphanumeric;\n  }\n};\nconst parsePostFn = arg => {\n  if (typeof arg === 'function') {\n    return arg;\n  }\n  return value => value.trim().replace(/[^0-9]$/, '');\n};\nconst delimiter = '\\u00a7';\nfunction masker(fn) {\n  return args => {\n    const data = fn(args);\n    const pre = parsePreFn('pre' in data ? data.pre : null);\n    const post = parsePostFn('post' in data ? data.post : null);\n    const formatter = 'pattern' in data && data.pattern ? new stringMask(data.pattern, data.options || {}) : null;\n    const handler = 'handler' in data && typeof data.handler === 'function' ? data.handler : value => formatter ? formatter.apply(value) : value;\n    return (str, args = {}) => {\n      args = {\n        ...args,\n        delimiter\n      };\n      str = pre(str, args);\n      let [prefix, value] = (!str.includes(delimiter) ? `${delimiter}${str}` : str).split(delimiter);\n      value = handler(value, args);\n      return post(`${prefix}${value}`, args);\n    };\n  };\n}\nvar mask = masker(({\n  value: pattern\n}) => ({\n  pattern,\n  pre: filterAlphanumeric,\n  post: value => value.trim().replace(/[^a-zA-Z0-9]$/, '')\n}));\nconst patterns = {\n  us: '0000-00-00',\n  br: '00/00/0000'\n};\nvar date = masker(({\n  locale = null\n} = {}) => ({\n  pattern: patterns[locale || 'us'],\n  pre: filterNumbers\n}));\nconst handlers = {\n  get us() {\n    const phone = new stringMask('(000) 000-0000');\n    return value => phone.apply(value);\n  },\n  get br() {\n    const phone = new stringMask('(00) 0000-0000');\n    const phone9 = new stringMask('(00) 9 0000-0000');\n    const phone0800 = new stringMask('0000-000-0000');\n    return value => {\n      if (value.startsWith('0800'.slice(0, value.length))) {\n        return phone0800.apply(value);\n      } else if (value.length <= 10) {\n        return phone.apply(value);\n      }\n      return phone9.apply(value);\n    };\n  }\n};\nvar phone = masker(({\n  locale\n}) => {\n  const handler = handlers[locale || 'us'];\n  return {\n    pre: filterNumbers,\n    handler\n  };\n});\nconst config = {\n  us: {\n    thousand: ',',\n    decimal: '.'\n  },\n  br: {\n    thousand: '.',\n    decimal: ','\n  }\n};\nvar decimal = masker(({\n  locale,\n  value\n}) => {\n  const conf = config[locale || 'us'];\n  const patternParts = [`#${conf.thousand}##0`];\n  const precision = value || 0;\n  if (precision) {\n    patternParts.push(conf.decimal, new Array(precision).fill('0').join(''));\n  }\n  return {\n    pattern: patternParts.join(''),\n    options: {\n      reverse: true\n    },\n    pre(value, {\n      delimiter\n    }) {\n      if (!value) {\n        return '';\n      }\n      const sign = value.startsWith('-') ? '-' : '';\n      let [number, fraction = ''] = value.split(conf.decimal).map(filterNumbers);\n      if (fraction && fraction.length > precision) {\n        number = `${number}${fraction.slice(0, -precision)}`;\n        fraction = fraction.slice(-precision);\n      }\n      return [sign, delimiter, Number(number), fraction].join('');\n    },\n    post(value) {\n      return value;\n    }\n  };\n});\nvar number = masker(() => {\n  return {\n    pattern: '#0',\n    options: {\n      reverse: true\n    },\n    pre: filterNumbers\n  };\n});\nvar cpf = masker(() => ({\n  pattern: '000.000.000-00',\n  pre: filterNumbers\n}));\nvar cnpj = masker(() => ({\n  pattern: '00.000.000/0000-00',\n  pre: filterNumbers\n}));\nvar cep = masker(() => ({\n  pattern: '00.000-000',\n  pre: filterNumbers\n}));\nvar creditCard = masker(() => ({\n  pattern: '0000 0000 0000 0000',\n  pre: filterNumbers\n}));\nvar masks = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  mask: mask,\n  maskDate: date,\n  maskPhone: phone,\n  maskDecimal: decimal,\n  maskNumber: number,\n  maskCpf: cpf,\n  maskCnpj: cnpj,\n  maskCep: cep,\n  maskCc: creditCard\n});\nfunction updater(el, masker) {\n  const currentValue = el.value;\n  const oldValue = el.dataset.value;\n  if (oldValue === currentValue) {\n    return;\n  }\n  const newValue = masker(currentValue, {\n    el\n  });\n  if (newValue === currentValue) {\n    el.dataset.value = currentValue;\n    return;\n  } // Get current cursor position\n\n  let position = el.selectionEnd; // Find next cursor position\n\n  if (position === currentValue.length) {\n    position = newValue.length;\n  } else if (position > 0 && position <= newValue.length) {\n    const digit = currentValue.charAt(position - 1);\n    if (digit !== newValue.charAt(position - 1)) {\n      if (digit === newValue.charAt(position)) {\n        position += 1;\n      } else if (digit === newValue.charAt(position - 2)) {\n        position -= 1;\n      }\n    }\n  }\n  el.value = newValue;\n  el.dataset.value = newValue;\n  if (el === document.activeElement) {\n    // Restore cursor position\n    el.setSelectionRange(position, position);\n  }\n  el.dispatchEvent(createEvent('input'));\n}\nfunction make(maskerFn) {\n  const maskerMap = new WeakMap();\n  const inputMap = new WeakMap(); // const eventMap = new WeakMap();\n\n  return {\n    beforeMount(el, binding) {\n      const masker = maskerFn({\n        value: binding.value,\n        locale: binding.arg || Object.keys(binding.modifiers)[0] || null\n      });\n      const inputEl = getInputElement(el); // const eventHandler = ({ isTrusted }) => {\n      //   if (isTrusted) {\n      //     updater(inputEl, masker);\n      //   }\n      // };\n\n      maskerMap.set(el, masker);\n      inputMap.set(el, inputEl); // eventMap.set(el, eventHandler);\n      // inputEl.addEventListener('input', eventHandler);\n    },\n\n    mounted(el) {\n      updater(inputMap.get(el), maskerMap.get(el));\n    },\n    updated(el) {\n      updater(inputMap.get(el), maskerMap.get(el));\n    },\n    unmounted(el) {\n      // el.removeEventListener('input', inputMap.get(el));\n      maskerMap.delete(el);\n      inputMap.delete(el); // eventMap.delete(el);\n    }\n  };\n}\n\nconst install = function installPlugin(app) {\n  // Register directives\n  for (const name in masks) {\n    app.directive(name, make(masks[name]));\n  }\n};\nexport { install as default, filterAlphanumeric, filterLetters, filterNumbers, make as makeDirective, masker };","map":{"version":3,"names":["commonjsGlobal","globalThis","window","global","self","createCommonjsModule","fn","module","exports","stringMask","root","factory","tokens","pattern","_default","optional","recursive","transform","c","toLocaleUpperCase","toLocaleLowerCase","escape","isEscaped","pos","count","i","token","charAt","calcOptionalNumbersToUse","value","numbersInP","replace","length","numbersInV","concatChar","text","character","options","reverse","hasMoreTokens","inc","pc","hasMoreRecursiveTokens","insertChar","char","position","t","split","splice","join","StringMask","opt","usedefaults","prototype","process","proccess","result","valid","pattern2","formatted","valuePos","patternPos","optionalNumbersToUse","escapeNext","inRecursiveMode","steps","start","end","continueCondition","shift","push","vc","test","apply","validate","getInputElement","el","inputEl","tagName","toLowerCase","querySelector","Error","createEvent","name","event","document","initEvent","filterNumbers","v","filterLetters","filterAlphanumeric","parsePreFn","arg","parsePostFn","trim","delimiter","masker","args","data","pre","post","formatter","handler","str","prefix","includes","mask","patterns","us","br","date","locale","handlers","phone","phone9","phone0800","startsWith","slice","config","thousand","decimal","conf","patternParts","precision","Array","fill","sign","number","fraction","map","Number","cpf","cnpj","cep","creditCard","masks","Object","freeze","__proto__","maskDate","maskPhone","maskDecimal","maskNumber","maskCpf","maskCnpj","maskCep","maskCc","updater","currentValue","oldValue","dataset","newValue","selectionEnd","digit","activeElement","setSelectionRange","dispatchEvent","make","maskerFn","maskerMap","WeakMap","inputMap","beforeMount","binding","keys","modifiers","set","mounted","get","updated","unmounted","delete","install","installPlugin","app","directive","default","makeDirective"],"sources":["C:/Users/Thata/OneDrive/Ãrea de Trabalho/DesafioAccenture/desafiofullstack-app/node_modules/@devindex/vue-mask/dist/vue-mask.esm.js"],"sourcesContent":["var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction createCommonjsModule(fn) {\n  var module = { exports: {} };\n\treturn fn(module, module.exports), module.exports;\n}\n\nvar stringMask = createCommonjsModule(function (module, exports) {\n(function(root, factory) {\n    /* istanbul ignore next */\n    {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    }\n}(commonjsGlobal, function() {\n    var tokens = {\n        '0': {pattern: /\\d/, _default: '0'},\n        '9': {pattern: /\\d/, optional: true},\n        '#': {pattern: /\\d/, optional: true, recursive: true},\n        'A': {pattern: /[a-zA-Z0-9]/},\n        'S': {pattern: /[a-zA-Z]/},\n        'U': {pattern: /[a-zA-Z]/, transform: function(c) { return c.toLocaleUpperCase(); }},\n        'L': {pattern: /[a-zA-Z]/, transform: function(c) { return c.toLocaleLowerCase(); }},\n        '$': {escape: true}\n    };\n\n    function isEscaped(pattern, pos) {\n        var count = 0;\n        var i = pos - 1;\n        var token = {escape: true};\n        while (i >= 0 && token && token.escape) {\n            token = tokens[pattern.charAt(i)];\n            count += token && token.escape ? 1 : 0;\n            i--;\n        }\n        return count > 0 && count % 2 === 1;\n    }\n\n    function calcOptionalNumbersToUse(pattern, value) {\n        var numbersInP = pattern.replace(/[^0]/g,'').length;\n        var numbersInV = value.replace(/[^\\d]/g,'').length;\n        return numbersInV - numbersInP;\n    }\n\n    function concatChar(text, character, options, token) {\n        if (token && typeof token.transform === 'function') {\n            character = token.transform(character);\n        }\n        if (options.reverse) {\n            return character + text;\n        }\n        return text + character;\n    }\n\n    function hasMoreTokens(pattern, pos, inc) {\n        var pc = pattern.charAt(pos);\n        var token = tokens[pc];\n        if (pc === '') {\n            return false;\n        }\n        return token && !token.escape ? true : hasMoreTokens(pattern, pos + inc, inc);\n    }\n\n    function hasMoreRecursiveTokens(pattern, pos, inc) {\n        var pc = pattern.charAt(pos);\n        var token = tokens[pc];\n        if (pc === '') {\n            return false;\n        }\n        return token && token.recursive ? true : hasMoreRecursiveTokens(pattern, pos + inc, inc);\n    }\n\n    function insertChar(text, char, position) {\n        var t = text.split('');\n        t.splice(position, 0, char);\n        return t.join('');\n    }\n\n    function StringMask(pattern, opt) {\n        this.options = opt || {};\n        this.options = {\n            reverse: this.options.reverse || false,\n            usedefaults: this.options.usedefaults || this.options.reverse\n        };\n        this.pattern = pattern;\n    }\n\n    StringMask.prototype.process = function proccess(value) {\n        if (!value) {\n            return {result: '', valid: false};\n        }\n        value = value + '';\n        var pattern2 = this.pattern;\n        var valid = true;\n        var formatted = '';\n        var valuePos = this.options.reverse ? value.length - 1 : 0;\n        var patternPos = 0;\n        var optionalNumbersToUse = calcOptionalNumbersToUse(pattern2, value);\n        var escapeNext = false;\n        var recursive = [];\n        var inRecursiveMode = false;\n\n        var steps = {\n            start: this.options.reverse ? pattern2.length - 1 : 0,\n            end: this.options.reverse ? -1 : pattern2.length,\n            inc: this.options.reverse ? -1 : 1\n        };\n\n        function continueCondition(options) {\n            if (!inRecursiveMode && !recursive.length && hasMoreTokens(pattern2, patternPos, steps.inc)) {\n                // continue in the normal iteration\n                return true;\n            } else if (!inRecursiveMode && recursive.length &&\n                hasMoreRecursiveTokens(pattern2, patternPos, steps.inc)) {\n                // continue looking for the recursive tokens\n                // Note: all chars in the patterns after the recursive portion will be handled as static string\n                return true;\n            } else if (!inRecursiveMode) {\n                // start to handle the recursive portion of the pattern\n                inRecursiveMode = recursive.length > 0;\n            }\n\n            if (inRecursiveMode) {\n                var pc = recursive.shift();\n                recursive.push(pc);\n                if (options.reverse && valuePos >= 0) {\n                    patternPos++;\n                    pattern2 = insertChar(pattern2, pc, patternPos);\n                    return true;\n                } else if (!options.reverse && valuePos < value.length) {\n                    pattern2 = insertChar(pattern2, pc, patternPos);\n                    return true;\n                }\n            }\n            return patternPos < pattern2.length && patternPos >= 0;\n        }\n\n        /**\n         * Iterate over the pattern's chars parsing/matching the input value chars\n         * until the end of the pattern. If the pattern ends with recursive chars\n         * the iteration will continue until the end of the input value.\n         *\n         * Note: The iteration must stop if an invalid char is found.\n         */\n        for (patternPos = steps.start; continueCondition(this.options); patternPos = patternPos + steps.inc) {\n            // Value char\n            var vc = value.charAt(valuePos);\n            // Pattern char to match with the value char\n            var pc = pattern2.charAt(patternPos);\n\n            var token = tokens[pc];\n            if (recursive.length && token && !token.recursive) {\n                // In the recursive portion of the pattern: tokens not recursive must be seen as static chars\n                token = null;\n            }\n\n            // 1. Handle escape tokens in pattern\n            // go to next iteration: if the pattern char is a escape char or was escaped\n            if (!inRecursiveMode || vc) {\n                if (this.options.reverse && isEscaped(pattern2, patternPos)) {\n                    // pattern char is escaped, just add it and move on\n                    formatted = concatChar(formatted, pc, this.options, token);\n                    // skip escape token\n                    patternPos = patternPos + steps.inc;\n                    continue;\n                } else if (!this.options.reverse && escapeNext) {\n                    // pattern char is escaped, just add it and move on\n                    formatted = concatChar(formatted, pc, this.options, token);\n                    escapeNext = false;\n                    continue;\n                } else if (!this.options.reverse && token && token.escape) {\n                    // mark to escape the next pattern char\n                    escapeNext = true;\n                    continue;\n                }\n            }\n\n            // 2. Handle recursive tokens in pattern\n            // go to next iteration: if the value str is finished or\n            //                       if there is a normal token in the recursive portion of the pattern\n            if (!inRecursiveMode && token && token.recursive) {\n                // save it to repeat in the end of the pattern and handle the value char now\n                recursive.push(pc);\n            } else if (inRecursiveMode && !vc) {\n                // in recursive mode but value is finished. Add the pattern char if it is not a recursive token\n                formatted = concatChar(formatted, pc, this.options, token);\n                continue;\n            } else if (!inRecursiveMode && recursive.length > 0 && !vc) {\n                // recursiveMode not started but already in the recursive portion of the pattern\n                continue;\n            }\n\n            // 3. Handle the value\n            // break iterations: if value is invalid for the given pattern\n            if (!token) {\n                // add char of the pattern\n                formatted = concatChar(formatted, pc, this.options, token);\n                if (!inRecursiveMode && recursive.length) {\n                    // save it to repeat in the end of the pattern\n                    recursive.push(pc);\n                }\n            } else if (token.optional) {\n                // if token is optional, only add the value char if it matchs the token pattern\n                //                       if not, move on to the next pattern char\n                if (token.pattern.test(vc) && optionalNumbersToUse) {\n                    formatted = concatChar(formatted, vc, this.options, token);\n                    valuePos = valuePos + steps.inc;\n                    optionalNumbersToUse--;\n                } else if (recursive.length > 0 && vc) {\n                    valid = false;\n                    break;\n                }\n            } else if (token.pattern.test(vc)) {\n                // if token isn't optional the value char must match the token pattern\n                formatted = concatChar(formatted, vc, this.options, token);\n                valuePos = valuePos + steps.inc;\n            } else if (!vc && token._default && this.options.usedefaults) {\n                // if the token isn't optional and has a default value, use it if the value is finished\n                formatted = concatChar(formatted, token._default, this.options, token);\n            } else {\n                // the string value don't match the given pattern\n                valid = false;\n                break;\n            }\n        }\n\n        return {result: formatted, valid: valid};\n    };\n\n    StringMask.prototype.apply = function(value) {\n        return this.process(value).result;\n    };\n\n    StringMask.prototype.validate = function(value) {\n        return this.process(value).valid;\n    };\n\n    StringMask.process = function(value, pattern, options) {\n        return new StringMask(pattern, options).process(value);\n    };\n\n    StringMask.apply = function(value, pattern, options) {\n        return new StringMask(pattern, options).apply(value);\n    };\n\n    StringMask.validate = function(value, pattern, options) {\n        return new StringMask(pattern, options).validate(value);\n    };\n\n    return StringMask;\n}));\n});\n\nconst getInputElement = el => {\n  const inputEl = el.tagName.toLowerCase() !== 'input' ? el.querySelector('input:not([readonly])') : el;\n\n  if (!inputEl) {\n    throw new Error('Mask directive requires at least one input');\n  }\n\n  return inputEl;\n};\nfunction createEvent(name) {\n  const event = document.createEvent('HTMLEvents');\n  event.initEvent(name, true, true);\n  return event;\n}\nconst filterNumbers = v => v.replace(/\\D/g, '');\nconst filterLetters = v => v.replace(/[^a-zA-Z]/g, '');\nconst filterAlphanumeric = v => v.replace(/[^a-zA-Z0-9]/g, '');\nconst parsePreFn = arg => {\n  if (typeof arg === 'function') {\n    return arg;\n  }\n\n  switch (arg) {\n    case 'filter-number':\n      return filterNumbers;\n\n    case 'filter-letter':\n      return filterLetters;\n\n    default:\n      return filterAlphanumeric;\n  }\n};\nconst parsePostFn = arg => {\n  if (typeof arg === 'function') {\n    return arg;\n  }\n\n  return value => value.trim().replace(/[^0-9]$/, '');\n};\n\nconst delimiter = '\\u00a7';\nfunction masker(fn) {\n  return args => {\n    const data = fn(args);\n    const pre = parsePreFn('pre' in data ? data.pre : null);\n    const post = parsePostFn('post' in data ? data.post : null);\n    const formatter = 'pattern' in data && data.pattern ? new stringMask(data.pattern, data.options || {}) : null;\n    const handler = 'handler' in data && typeof data.handler === 'function' ? data.handler : value => formatter ? formatter.apply(value) : value;\n    return (str, args = {}) => {\n      args = { ...args,\n        delimiter\n      };\n      str = pre(str, args);\n      let [prefix, value] = (!str.includes(delimiter) ? `${delimiter}${str}` : str).split(delimiter);\n      value = handler(value, args);\n      return post(`${prefix}${value}`, args);\n    };\n  };\n}\n\nvar mask = masker(({\n  value: pattern\n}) => ({\n  pattern,\n  pre: filterAlphanumeric,\n  post: value => value.trim().replace(/[^a-zA-Z0-9]$/, '')\n}));\n\nconst patterns = {\n  us: '0000-00-00',\n  br: '00/00/0000'\n};\nvar date = masker(({\n  locale = null\n} = {}) => ({\n  pattern: patterns[locale || 'us'],\n  pre: filterNumbers\n}));\n\nconst handlers = {\n  get us() {\n    const phone = new stringMask('(000) 000-0000');\n    return value => phone.apply(value);\n  },\n\n  get br() {\n    const phone = new stringMask('(00) 0000-0000');\n    const phone9 = new stringMask('(00) 9 0000-0000');\n    const phone0800 = new stringMask('0000-000-0000');\n    return value => {\n      if (value.startsWith('0800'.slice(0, value.length))) {\n        return phone0800.apply(value);\n      } else if (value.length <= 10) {\n        return phone.apply(value);\n      }\n\n      return phone9.apply(value);\n    };\n  }\n\n};\nvar phone = masker(({\n  locale\n}) => {\n  const handler = handlers[locale || 'us'];\n  return {\n    pre: filterNumbers,\n    handler\n  };\n});\n\nconst config = {\n  us: {\n    thousand: ',',\n    decimal: '.'\n  },\n  br: {\n    thousand: '.',\n    decimal: ','\n  }\n};\nvar decimal = masker(({\n  locale,\n  value\n}) => {\n  const conf = config[locale || 'us'];\n  const patternParts = [`#${conf.thousand}##0`];\n  const precision = value || 0;\n\n  if (precision) {\n    patternParts.push(conf.decimal, new Array(precision).fill('0').join(''));\n  }\n\n  return {\n    pattern: patternParts.join(''),\n    options: {\n      reverse: true\n    },\n\n    pre(value, {\n      delimiter\n    }) {\n      if (!value) {\n        return '';\n      }\n\n      const sign = value.startsWith('-') ? '-' : '';\n      let [number, fraction = ''] = value.split(conf.decimal).map(filterNumbers);\n\n      if (fraction && fraction.length > precision) {\n        number = `${number}${fraction.slice(0, -precision)}`;\n        fraction = fraction.slice(-precision);\n      }\n\n      return [sign, delimiter, Number(number), fraction].join('');\n    },\n\n    post(value) {\n      return value;\n    }\n\n  };\n});\n\nvar number = masker(() => {\n  return {\n    pattern: '#0',\n    options: {\n      reverse: true\n    },\n    pre: filterNumbers\n  };\n});\n\nvar cpf = masker(() => ({\n  pattern: '000.000.000-00',\n  pre: filterNumbers\n}));\n\nvar cnpj = masker(() => ({\n  pattern: '00.000.000/0000-00',\n  pre: filterNumbers\n}));\n\nvar cep = masker(() => ({\n  pattern: '00.000-000',\n  pre: filterNumbers\n}));\n\nvar creditCard = masker(() => ({\n  pattern: '0000 0000 0000 0000',\n  pre: filterNumbers\n}));\n\nvar masks = /*#__PURE__*/Object.freeze({\n\t__proto__: null,\n\tmask: mask,\n\tmaskDate: date,\n\tmaskPhone: phone,\n\tmaskDecimal: decimal,\n\tmaskNumber: number,\n\tmaskCpf: cpf,\n\tmaskCnpj: cnpj,\n\tmaskCep: cep,\n\tmaskCc: creditCard\n});\n\nfunction updater(el, masker) {\n  const currentValue = el.value;\n  const oldValue = el.dataset.value;\n\n  if (oldValue === currentValue) {\n    return;\n  }\n\n  const newValue = masker(currentValue, {\n    el\n  });\n\n  if (newValue === currentValue) {\n    el.dataset.value = currentValue;\n    return;\n  } // Get current cursor position\n\n\n  let position = el.selectionEnd; // Find next cursor position\n\n  if (position === currentValue.length) {\n    position = newValue.length;\n  } else if (position > 0 && position <= newValue.length) {\n    const digit = currentValue.charAt(position - 1);\n\n    if (digit !== newValue.charAt(position - 1)) {\n      if (digit === newValue.charAt(position)) {\n        position += 1;\n      } else if (digit === newValue.charAt(position - 2)) {\n        position -= 1;\n      }\n    }\n  }\n\n  el.value = newValue;\n  el.dataset.value = newValue;\n\n  if (el === document.activeElement) {\n    // Restore cursor position\n    el.setSelectionRange(position, position);\n  }\n\n  el.dispatchEvent(createEvent('input'));\n}\n\nfunction make(maskerFn) {\n  const maskerMap = new WeakMap();\n  const inputMap = new WeakMap(); // const eventMap = new WeakMap();\n\n  return {\n    beforeMount(el, binding) {\n      const masker = maskerFn({\n        value: binding.value,\n        locale: binding.arg || Object.keys(binding.modifiers)[0] || null\n      });\n      const inputEl = getInputElement(el); // const eventHandler = ({ isTrusted }) => {\n      //   if (isTrusted) {\n      //     updater(inputEl, masker);\n      //   }\n      // };\n\n      maskerMap.set(el, masker);\n      inputMap.set(el, inputEl); // eventMap.set(el, eventHandler);\n      // inputEl.addEventListener('input', eventHandler);\n    },\n\n    mounted(el) {\n      updater(inputMap.get(el), maskerMap.get(el));\n    },\n\n    updated(el) {\n      updater(inputMap.get(el), maskerMap.get(el));\n    },\n\n    unmounted(el) {\n      // el.removeEventListener('input', inputMap.get(el));\n      maskerMap.delete(el);\n      inputMap.delete(el); // eventMap.delete(el);\n    }\n\n  };\n}\n\nconst install = function installPlugin(app) {\n  // Register directives\n  for (const name in masks) {\n    app.directive(name, make(masks[name]));\n  }\n};\n\nexport { install as default, filterAlphanumeric, filterLetters, filterNumbers, make as makeDirective, masker };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}